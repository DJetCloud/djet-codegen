package {{basePackage}}.rsql

import cz.jirutka.rsql.parser.ast.ComparisonOperator
import org.springframework.data.jpa.domain.Specification
import java.util.*
import java.util.stream.Collectors
import javax.persistence.criteria.CriteriaBuilder
import javax.persistence.criteria.CriteriaQuery
import javax.persistence.criteria.Predicate
import javax.persistence.criteria.Root

@Suppress("ReturnCount", "ComplexMethod")
class GenericRsqlSpecification<E>(
        private val property: String,
        private val operator: ComparisonOperator,
        private val arguments: List<String>) : Specification<E> {

    override fun toPredicate(root: Root<E>, query: CriteriaQuery<*>, builder: CriteriaBuilder): Predicate? {
        val args = castArguments(root)
        val argument = args[0]
        when (RsqlSearchOperation.getSimpleOperator(operator)) {
            RsqlSearchOperation.EQUAL -> {
                return when (argument) {
                    is String -> {
                        builder.like(root[property], argument.toString().replace('*', '%'))
                    }
                    null -> {
                        builder.isNull(root.get<Any>(property))
                    }
                    else -> {
                        builder.equal(root.get<Any>(property), argument)
                    }
                }
            }
            RsqlSearchOperation.NOT_EQUAL -> {
                return when (argument) {
                    is String -> {
                        builder.notLike(root[property], argument.toString().replace('*', '%'))
                    }
                    null -> {
                        builder.isNotNull(root.get<Any>(property))
                    }
                    else -> {
                        builder.notEqual(root.get<Any>(property), argument)
                    }
                }
            }
            RsqlSearchOperation.GREATER_THAN -> {
                return builder.greaterThan(root[property], argument.toString())
            }
            RsqlSearchOperation.GREATER_THAN_OR_EQUAL -> {
                return builder.greaterThanOrEqualTo(root[property], argument.toString())
            }
            RsqlSearchOperation.LESS_THAN -> {
                return builder.lessThan(root[property], argument.toString())
            }
            RsqlSearchOperation.LESS_THAN_OR_EQUAL -> {
                return builder.lessThanOrEqualTo(root[property], argument.toString())
            }
            RsqlSearchOperation.IN -> return root.get<Collection<Any>>(property).`in`(args)
            RsqlSearchOperation.NOT_IN -> return builder.not(root.get<Collection<Any>>(property).`in`(args))
        }
        return null
    }

    private fun castArguments(root: Root<E>): List<Any> {
        val type = root.get<Any>(property).javaType

        return arguments.stream().map<Any> { arg: String ->
            when (type) {
                Int::class.java -> {
                    return@map arg.toInt()
                }
                Long::class.java -> {
                    return@map arg.toLong()
                }
                UUID::class.java -> {
                    return@map UUID.fromString(arg)
                }
                else -> {
                    return@map arg
                }
            }
        }.collect(Collectors.toList())
    }
}
